package ui

type AccordionItem struct {
	Title   string // Title of the accordion item
	Content string // Content of the accordion item (text)
	Open    bool   // Whether the item is open by default
}

type AccordionVariant int

const (
	AccordionBasic AccordionVariant = iota
	AccordionBordered
	AccordionFlush
)

type AccordionProp struct {
	Items      []AccordionItem
	Variant    AccordionVariant
	Icon       IconKind // Optional: Override default arrow icon
	Class      string
	Id         string
	Attributes templ.Attributes
}

// Accordion renders a list of collapsible items using details/summary tags.
templ Accordion(prop AccordionProp) {
	<div
		if prop.Id != "" {
			id={ prop.Id }
		}
		class={ accordionClass(prop) }
		{ prop.Attributes... }
	>
		for _, item := range prop.Items {
			<details
				class="accordion__item"
				if item.Open {
					open
				}
			>
				<summary class="accordion__summary">
					<span class="accordion__title">{ item.Title }</span>
					if prop.Icon != 0 {
						@Icon(IconProp{Type: prop.Icon, Size: IconSizeSM, Class: "accordion__icon"})
					} else {
						@Icon(IconProp{Type: IconChevronDown, Size: IconSizeSM, Class: "accordion__icon"})
					}
				</summary>
				<div class="accordion__content">
					<div class="accordion__body">
						{ item.Content }
					</div>
				</div>
			</details>
		}
	</div>
}

// accordionClass generates the CSS class for the accordion container.
func accordionClass(prop AccordionProp) string {
	base := "accordion"

	variantClass := ""
	switch prop.Variant {
	case AccordionBordered:
		variantClass = "accordion--bordered"
	case AccordionFlush:
		variantClass = "accordion--flush"
	default:
		variantClass = "accordion--basic"
	}

	result := base + " " + variantClass
	if prop.Class != "" {
		result += " " + prop.Class
	}
	return result
}
